# 内存地址

8086是一种16位的微处理器，它有20根地址线，可以寻址1MB（220）的内存空间。但是，8086的内部寄存器只有16位，所以它不能直接表示20位的物理地址。为了解决这个问题，8086采用了一种分段机制，将内存空间划分为多个段，每个段最大为64KB（216）。

每个段都有一个16位的段地址（也叫段基址或段首地址），它表示该段在内存中的起始位置。每个段内的数据都有一个16位的偏移地址（也叫偏移量或有效地址），它表示该数据在该段内的相对位置。要访问一个数据，就需要给出它所在的段地址和偏移地址。

为了将16位的段地址和偏移地址合成20位的物理地址，8086使用了一个地址加法器，它的计算公式是：

`物理地址 = 段地址 * 16 + 偏移地址`

这里，**段地址乘以16相当于左移4位，在低位补0**。这样，每个段都是以16字节为单位对齐的，也就是说，每个段的起始位置都是16的倍数。这样做的好处是可以增加可用的段数，最多可以有65536（2^16）个段。**同时，偏移地址也是个 16 位的二进制数，故一个段中又有 65536 个字节，即64 KB**。

![[202304211730182.png]]

为了方便表示一个数据的逻辑地址（由段地址和偏移地址组成），8086使用了一种冒号分隔的格式，如下：

`逻辑地址 = 段地址:偏移地址`

例如，9000:0表示一个数据在9000H这个段中，偏移量为0H。它对应的物理地址是90000H。

为了存放不同类型的数据和代码，8086提供了四个专用的段寄存器：CS、DS、SS和ES。它们分别用来存放代码段、数据段、堆栈段和附加段的段地址。这样，在执行指令或访问数据时，就可以根据不同的寄存器来确定不同的段。

例如，在执行指令时，指令所在的物理地址由CS和IP两个寄存器给出，其中CS存放指令所在的代码段地址，IP存放指令在代码段中的偏移量。`物理地址 = CS * 16 + IP`。

在访问数据时，数据所在的物理地址由DS和一个通用寄存器或一个立即数给出，其中DS存放数据所在的数据段地址，通用寄存器或立即数存放数据在数据段中的偏移量。`物理地址 = DS * 16 + 偏移量`。

在操作堆栈时，堆栈元素所在的物理地址由SS和SP两个寄存器给出，其中SS存放堆栈所在的堆栈段地址，SP存放堆栈顶元素在堆栈段中的偏移量。`物理地址 = SS * 16 + SP`。

ES是一个附加的段寄存器，它可以用来访问另一个数据段或代码段。它通常和SI或DI配合使用，形成基址变址寻址方式。

除了上述四个专用寄存器外，8086还有四个通用寄存器：AX、BX、CX和DX。它们可以用来保存数据或参与运算。它们也可以作为偏移量来访问内存中的数据。其中AX、BX、CX和DX可以分别分为两个8位的寄存器：AH、AL、BH、BL、CH、CL、DH和DL。

8086还有两个索引寄存器：SI和DI。它们可以用来保存数据或参与运算。它们也可以作为偏移量来访问内存中的数据，通常和DS或ES配合使用，形成寄存器间接寻址方式或寄存器相对寻址方式。

8086还有一个指针寄存器：BP。它可以用来保存数据或参与运算。它也可以作为偏移量来访问内存中的数据，通常和SS配合使用，形成基址寻址方式或相对基址寻址方式。

8086还有一个标志寄存器：FLAGS。它用来保存一些标志位，表示CPU的状态或运算的结果。例如，CF表示进位标志，ZF表示零标志，SF表示符号标志，OF表示溢出标志等。

以上就是我对8086的内存地址相关的知识的讲解，希望您能够理解和掌握。如果您还有其他问题，欢迎继续向我提问。😊***bing 可爱捏***

# 内存的区域划分

计算机内存通常被划分为不同的区域，每个区域用于存储不同类型的数据和执行不同的功能。这些内存区域的划分在不同的计算机体系结构和操作系统中可能会有一些变化，但通常包括以下主要区域：

1. **代码区域（Code Segment）：** 代码区域存储正在执行的程序的机器指令。这是程序的可执行代码部分，通常包括程序的指令和常量数据。在多任务操作系统中，每个运行的程序或进程都有自己的代码区域，以保证程序之间的隔离。

2. **数据区域（Data Segment）：** 数据区域用于存储程序的静态数据，如全局变量和静态变量。这些数据在程序运行时被初始化，通常不会频繁改变。

3. **堆区域（Heap）：** 堆区域用于动态分配内存，通常由程序员手动控制或通过动态内存分配函数（如 `malloc` 和 `free`）来管理。堆内存通常用于存储动态数据结构，如动态数组和堆栈，以及在程序运行期间动态创建和释放的数据。

4. **堆栈区域（Stack）：** 堆栈区域用于存储函数调用的状态信息，包括局部变量、函数参数、返回地址以及一些寄存器的状态。它以后入先出（LIFO）的方式管理数据，支持函数的递归调用和执行流程的控制。

5. **操作系统区域（Operating System Area）：** 这个区域由操作系统使用，用于存储操作系统的内核数据结构、系统调用接口和其他操作系统相关的数据。通常，用户程序不能直接访问操作系统区域。

6. **共享库区域（Shared Library Area）：** 这个区域用于存储共享库（动态链接库），多个程序可以共享相同的库，以减少内存占用和提高代码重用性。

7. **内存映射区域（Memory-Mapped Area）：** 这个区域用于将文件或设备映射到内存，以便以内存访问的方式来读写文件或进行 I/O 操作。

8. **堆外区域（Off-heap Area）：** 堆外区域是一些非堆内存，通常用于存储大量数据或需要特殊内存管理的数据。它包括一些内存映射文件、共享内存和其他非标准内存分配方式。

这些内存区域的划分和管理方式在不同的操作系统和编程语言中会有所不同，但它们一起构成了程序的内存地址空间，允许程序存储和访问不同类型的数据。了解这些内存区域的存在和用途对于编写高效、稳定和可维护的程序至关重要。



# 函数的局部变量是怎样进入堆栈的呢 ？

函数的局部变量通常是通过在堆栈中分配内存来进行存储的。当一个函数被调用时，一些步骤会发生，以在堆栈上分配内存以存储局部变量和其他与函数调用相关的信息。以下是关于局部变量如何进入堆栈的一般步骤：

1. **函数调用：** 当一个函数被调用时，当前函数的执行状态（包括寄存器状态和返回地址）被保存在堆栈中，以便在函数返回后可以正确地恢复执行。

2. **局部变量分配：** 在函数开始执行时，需要分配一些内存来存储局部变量。这通常是通过修改堆栈指针（ESP 或 RSP，具体取决于架构）来完成的。

3. **堆栈指针的减小：** 堆栈指针减小了一个适当的值，以便为局部变量分配足够的空间。通常，堆栈指针向下移动的距离等于局部变量需要的总字节数。

4. **局部变量的使用：** 一旦堆栈空间被分配，函数可以使用这些空间来存储和操作局部变量。这些变量在堆栈上是相对于堆栈指针的偏移量来访问的。

5. **函数执行：** 函数执行期间，它可以在局部变量中存储和操作数据。这些变量的作用范围通常局限于函数内部，不可被外部函数访问。

6. **函数返回：** 当函数执行完毕时，它会释放局部变量所占用的堆栈空间，通常通过将堆栈指针恢复到原始状态来完成。然后，函数将从堆栈中弹出保存的执行状态，包括返回地址，以继续执行调用者函数。

这种方式通过堆栈来存储局部变量确保了函数调用之间的隔离和独立性，因为每个函数都有自己的堆栈帧，局部变量不会相互干扰。这也使得递归函数调用成为可能，因为每个递归调用都会有自己的局部变量存储空间。